module Ctl.Internal.Plutus.Types.DataSchema
  ( PSchema
  , class HasPlutusSchema
  , PNil
  , PCons
  , ApPCons
  , Id
  , I
  , type (:+)
  , IxK
  , MkIxK
  , MkIxK_
  , type (@@)
  , Field
  , MkField
  , MkField_
  , type (:=)
  , class SchemaToRowList
  , class PlutusSchemaToRowListI
  , class AllUnique2
  , class ValidPlutusSchema
  ) where

import Ctl.Internal.TypeLevel.Nat (Nat)
import Ctl.Internal.TypeLevel.RowList (class AllUniqueLabels)
import Ctl.Internal.TypeLevel.RowList.Unordered.Indexed
  ( class AllUniqueLabelsI
  , class UniqueIndices
  , ConsI
  , NilI
  , RowListI
  )
import Type.RowList (Cons, Nil, RowList)

{- This modules defines various data types (kinds) which are used to encode enough the *structure* of the Plutus Data that corresponds to a
   given data type at the type level.

   There are three reason why this is needed:

   1) The previous implementation of ToData/FromData does not encode the order of record entries. Because RowLists are lexicographically sorted
      and Plutus Data is not, this rendered the library incompatible with PureScript record types generated by purescript-bridge. This provides a way to
      encode that order.

   2) The previous implementation of ToData/FromData relied upon a HasConstrIndices class which encoded the index corresponding to a
      Symbol representation of a constructor's name at the *term level*. This is not in itself bad. However, it is possible (in both Haskell and PureScript)
      to define sum types such as:

      ```
      data Foo = FooA {foo :: String, fooo :: Int}
               | FooB {fooo :: Bool, foo :: Bool}
      ```

      In cases like this, where multiple constructors of the sum type accept records as arguments and where those records share labels
      with each other, the Plutus Data index of a record entry cannot be determined solely by the type (Foo) and the label ("foo","fooo") and must be
      represented in a dependent manner with respect to the constructor name. (I.e. you need to know which constructor a given record belongs to in order
      to determine its index).

      I do not believe that it is possible to make FromData work without a type level representation of the indices of each record entry, and it would be difficult
      (if not strictly impossible) to combine the term-level HasConstrIndices approach with a type level IndexedRecField approach, and the schema implented here unifies all
      of the required information in a single place.

   3) Ergonomics/Safety. By encoding everything at the type level, we can express sophisticated constraints on the schema to ensure that patently invalid schemata are
      rejected at compile time. This reduces the burden and complexity of tests, and allows us to detect subtle mistakes in generated or handwritten instances that might
      otherwise only be determinable from emulator trace errors (which are, to put it mildly, not ideal). By defining Schema types here, we are also able to provide a syntax
      for the schema which is visually close to a data declaration and easy to generate.

-}

{- <<< Plutus Data Schema + Associated types/kinds/data >>> -}

-- | A type level Identity "functor kind". This is mainly used to overload the ':=' type operator.
data Id :: forall (k :: Type). k -> Type
data Id k

foreign import data I :: forall (k :: Type). k -> Id k

-- | A kind (never exists as a term). This is the kind of @PCons@ and @PNil@.
data PSchema :: forall (k :: Type). k -> Type
data PSchema k

{-  A concrete Plutus Data schema. Morally equivalent to:  Row (Row Type). This is superfluous
   in the sense that we could simply do everything here with (RowListI (RowList Type)), which
   @PlutusSchema@s are all translated to, but this facilitates a more comprehensible syntax.
   (Conversely we could rewrite all of the RowList/RowListI machinery in terms of this, but it
   would be much more difficult to read/debug/reason about).

   Here's an example:

    data FType
      = F0
          { f0A :: BigInt
          }
      | F1
          { f1A :: Boolean
          , f1B :: Boolean
          , f1C :: Boolean
          }
      | F2
          { f2A :: BigInt
          , f2B :: FType
          }

    instance
      HasPlutusSchema FType
        ( "F0" :=
              ( "f0A" := I BigInt
              :+ PNil)
           @@ Z

        :+ "F1" :=
              ( "f1A"  := I Boolean
              :+ "f1B" := I Boolean
              :+ "f1C" := I Boolean
              :+ PNil
              )
            @@ (S Z)

        :+ "F2" :=
              (  "f2A" := I BigInt
              :+ "f2B" := I FType
              :+ PNil
              )
            @@ (S (S Z))

        :+ PNil
        )

Note that a PSchema encodes two pieces of information:

1) The index of each *constructor* of a data type. This information is encoded in the "outer" RowListI.
   In the above example, these are "F0" (Z), "F1" (S Z), and "F2" (S (S Z))

2) The correct on-chain ordering of each record field. This is encoded implicitly by the ordering of the fields in each inner list (i.e. we do not provide a specific index for record fields).
   If a constructor does not have a Record argument, we do not need to encode any information about that argument. For example, the type:

    data GType
      = G0 BigInt
      | G1 Boolean Boolean Boolean
      | G2 BigInt GType

   would have a much simpler Schema:

   instance
     HasPlutusSchema GType
       ( "G0" := PNil @@ Z
       :+ "G1" := PNil @@ (S Z)
       :+ "G2" := PNil @@ (S (S Z))
       :+ PNil)

   The sole purpose of the inner list is to ensure correct translation to and from Plutus Data for record types
   when using the generic functions in ToData/FromData. Since GType's constructors do not have record arguments,
   no additional information is needed in the inner lists.
-}

type PlutusSchema = PSchema (PSchema Type)

-- | A class used to associate types with a Plutus Data Schema. The fundeps *should* guarantee
-- | that only one schema can exist for each type. This allows us to make the compiler select the
-- | schema associated with a particular type.
class HasPlutusSchema
  :: Type -> PlutusSchema -> Constraint
class HasPlutusSchema t schema | t -> schema

-- | Listlike constructors for the PSchema kind.
foreign import data PNil :: forall (k :: Type). PSchema k
foreign import data PCons
  :: forall (k :: Type). Field k -> PSchema k -> PSchema k

-- | Type synonym which is used to provide syntatic sugar to PCons. You can think of :+ as a type level version of : for PSchema
type ApPCons :: forall (k :: Type). Field k -> PSchema k -> PSchema k
type ApPCons x xs = PCons x xs

infixr 0 type ApPCons as :+

-- | Indexed kind. A kind representing a type @k@ indexed by a type level natural number @n@.
data IxK :: forall (k :: Type). k -> Type
data IxK k

-- | A data type of Kind (IxK k n) for some k and n
foreign import data MkIxK :: forall (k :: Type). Nat -> k -> IxK k

-- | Syntactic sugar which allows us to represent MkIxK as a type operator
type MkIxK_
  :: forall k1. k1 -> Nat -> IxK k1 -- FIXME(@gnumonik): s/k1/k it complains
type MkIxK_ k n = MkIxK n k

infixr 9 type MkIxK_ as @@

-- | A kind which is used to represent pairs of Symbols and IxKs. A fancy type level tuple, more or less.
data Field :: forall (k :: Type). k -> Type
data Field k

-- | A data type of Kind (Field k)
foreign import data MkField
  :: forall (k :: Type) (f :: Type -> Type). Symbol -> f k -> Field k

-- | Type synonym used to represent MkField as a type operator.
type MkField_
  :: forall (f :: Type -> Type) (k :: Type). Symbol -> f k -> Field k
type MkField_ lbl ixty = MkField lbl ixty

infixr 8 type MkField_ as :=

{- <<< Constraints used to provide compile-time validation of a PSchema >>> -}

-- TODO: See if we can optimize this. Slows down compilation considerably for complex types.
-- GH Issue: https://github.com/Plutonomicon/cardano-transaction-lib/issues/433
-- | A class which ensures that the Nat indices of the RowListI are unique & that the Symbol
-- | labels of both the RowListI and RowList in a RowListI (RowList k) all contain unique labels
-- | (relative to  their "level", i.e., two record arguments of *different* constructors can
-- | have overlapping labels, but constructor names cannot overlap, nor can two labels or indices
-- | of the *same* record)
class AllUnique2 :: forall (k :: Type). RowListI (RowList k) -> Constraint
class AllUnique2 rList

instance AllUnique2 NilI
else instance
  ( AllUniqueLabels a
  , AllUniqueLabelsI (ConsI l a n xs)
  , UniqueIndices (ConsI l a n xs)
  , AllUnique2 xs
  ) =>
  AllUnique2 (ConsI l a n xs)

-- | The class which validates a Plutus Schema. To make use of genericFromData / genericToData,
-- | a type must have an associated Plutus Data schema which satisfies this constraint.
class ValidPlutusSchema :: PlutusSchema -> RowListI (RowList Type) -> Constraint
class
  ( PlutusSchemaToRowListI schema list
  , AllUnique2 list
  ) <=
  ValidPlutusSchema schema list
  | schema -> list

instance
  ( PlutusSchemaToRowListI schema list
  , AllUnique2 list
  ) =>
  ValidPlutusSchema schema list

-- | Helper type classes used to convert a PlutusSchema to a RowListI (RowList k). Should not need to be used outside of this module.
class SchemaToRowList
  :: forall (k :: Type). PSchema k -> RowList k -> Constraint
class SchemaToRowList schema list | schema -> list

instance SchemaToRowList PNil Nil
else instance
  ( SchemaToRowList xs xs'
  ) =>
  SchemaToRowList (PCons (MkField l (I k)) xs) (Cons l k xs')

class PlutusSchemaToRowListI
  :: PlutusSchema -> RowListI (RowList Type) -> Constraint
class PlutusSchemaToRowListI schema list | schema -> list

instance PlutusSchemaToRowListI PNil NilI
else instance
  ( PlutusSchemaToRowListI xs xs'
  , SchemaToRowList a a'
  ) =>
  PlutusSchemaToRowListI (PCons (MkField l (MkIxK n a)) xs) (ConsI l a' n xs')
